 Plan de trabajo â€“ 7 dÃ­as
ğŸŸ¢ DÃ­a 1 â€“ Preparativos y carga de pesos
 Instala Eigen (librerÃ­a para matrices en C++)

 Elige estructura del proyecto (usa CMake o Make)

 Escribe cÃ³digo en C++ para:

Leer archivos .csv de pesos (usa std::ifstream o una pequeÃ±a librerÃ­a)

Cargar tensores en Eigen::MatrixXf o Eigen::VectorXf

 Prueba leer algunos pesos (ej. embeddings_word_embeddings_weight.csv) y muestra tamaÃ±o en consola

ğŸ§  Objetivo del dÃ­a: tener un sistema funcional que lea pesos de disco en C++

ğŸŸ¡ DÃ­a 2 â€“ Embeddings de entrada
 Implementa clase EmbeddingLayer

Word embeddings (multiplicaciÃ³n por embedding matrix)

Position embeddings (sumar por posiciÃ³n)

LayerNorm (usa peso y bias)

 Implementa un loader de tokens hardcodeado (simula entrada como {101, 2003, 102})

 Ejecuta y muestra los embeddings generados para una frase

ğŸ§  Objetivo del dÃ­a: obtener vectores de entrada listos para entrar al Transformer

ğŸŸ  DÃ­a 3 â€“ Capa Transformer (1 bloque)
 Implementa:

AtenciÃ³n (query, key, value, softmax, dot product, proyecciÃ³n)

Feedforward (2 capas lineales)

LayerNorms

 Crea clase TransformerBlock con todos estos pasos

 Carga los pesos para capa 0 y pÃ¡sale los embeddings de entrada

ğŸ§  Objetivo del dÃ­a: ejecutar una frase por una capa Transformer

ğŸŸ£ DÃ­a 4 â€“ Pipeline completo (6 capas)
 Carga pesos para las 6 capas Transformer

 Encadena 6 bloques Transformer

 Encapsula esto en una clase SentenceEncoder

ğŸ§  Objetivo del dÃ­a: obtener la secuencia de embeddings finales (shape: tokens Ã— 384)

ğŸ”µ DÃ­a 5 â€“ Pooling y comparaciÃ³n
 Implementa funciÃ³n mean_pooling() â†’ Vector de frase (384,)

 Implementa funciÃ³n cosine_similarity(a, b)

 Codifica dos frases distintas, aplica todo el pipeline, y muestra similitud en %

ğŸ§  Objetivo del dÃ­a: obtener similitud semÃ¡ntica de dos frases (output en consola)

ğŸ”´ DÃ­a 6 â€“ Limpieza y pruebas
 Refactoriza: divide en mÃ³dulos .h / .cpp

 AsegÃºrate que carga de pesos es flexible (por nombre de archivo)

 Crea archivos de prueba con frases tokenizadas (o crea wrapper en Python para pasarlas)

 Prueba con varias frases: similares / diferentes

ğŸ§  Objetivo del dÃ­a: tener una base limpia y funcional con pruebas simples

âš« DÃ­a 7 â€“ OptimizaciÃ³n y presentaciÃ³n
 Mide tiempos de inferencia

 Agrega validaciÃ³n de archivos y tamaÃ±os

 Documenta funciones clave (comentarios o README)

 Si es para presentaciÃ³n, crea script o interfaz CLI: